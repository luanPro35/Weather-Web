const API_KEY = "037b6dda3ea6bd588dd48b35ae88f478"; // Thay b·∫±ng API key c·ªßa b·∫°n
// Thi·∫øt l·∫≠p API_KEY to√†n c·ª•c ƒë·ªÉ c√°c file kh√°c c√≥ th·ªÉ s·ª≠ d·ª•ng
window.API_KEY = API_KEY;
const DEFAULT_CITY = "Da Nang"; // Fallback default city
 
// Weather icons mapping
const weatherIcons = {
  "01d": "‚òÄÔ∏è",
  "01n": "üåô",
  "02d": "‚õÖ",
  "02n": "‚òÅÔ∏è",
  "03d": "‚òÅÔ∏è",
  "03n": "‚òÅÔ∏è",
  "04d": "‚òÅÔ∏è",
  "04n": "‚òÅÔ∏è",
  "09d": "üåßÔ∏è",
  "09n": "üåßÔ∏è",
  "10d": "üå¶Ô∏è",
  "10n": "üåßÔ∏è",
  "11d": "‚õàÔ∏è",
  "11n": "‚õàÔ∏è",
  "13d": "‚ùÑÔ∏è",
  "13n": "‚ùÑÔ∏è",
  "50d": "üå´Ô∏è",
  "50n": "üå´Ô∏è",
};

// Navigation functions
function toggleMobileMenu() {
  const navMenu = document.getElementById("navMenu");
  navMenu.classList.toggle("active");
}

function showSection(sectionName, navLinkElement) {
  // Hide all sections
  const sections = document.querySelectorAll(".section");
  sections.forEach((section) => {
    section.style.display = "none";
  });

  // Show selected section
  const targetSection = document.getElementById(sectionName + "Section");
  if (targetSection) {
    targetSection.style.display = "block";
  }

  // Update active nav link
  const navLinks = document.querySelectorAll(".nav-link");
  navLinks.forEach((link) => {
    link.classList.remove("active");
  });
  if (navLinkElement) {
    navLinkElement.classList.add("active");
  }

  // Close mobile menu
  const mobileMenu = document.getElementById("navMenu");
  if (mobileMenu) {
    mobileMenu.classList.remove("active");
  }
}

/**
 * C·∫≠p nh·∫≠t h√¨nh n·ªÅn c·ªßa body d·ª±a tr√™n d·ªØ li·ªáu th·ªùi ti·∫øt.
 * @param {object} weatherData - D·ªØ li·ªáu th·ªùi ti·∫øt t·ª´ API.
 */
function setDynamicBackground(weatherData) {
  const body = document.body;
  const existingWeatherClasses = ['sunny', 'cloudy', 'overcast', 'rainy', 'snowy', 'stormy', 'clear-night', 'cloudy-night', 'overcast-night', 'misty', 'hot'];

  existingWeatherClasses.forEach(cls => {
    if (body.classList.contains(cls)) {
      body.classList.remove(cls);
    }
  });

  let newWeatherClass = ''; // Default to empty, so body's default CSS background applies if no match

  if (!weatherData || !weatherData.weather || !weatherData.weather[0] || !weatherData.main) {
    console.warn("D·ªØ li·ªáu th·ªùi ti·∫øt kh√¥ng ƒë·ªß ƒë·ªÉ x√°c ƒë·ªãnh h√¨nh n·ªÅn. S·ª≠ d·ª•ng n·ªÅn m·∫∑c ƒë·ªãnh.");
    return;
  }

  const description = weatherData.weather[0].description.toLowerCase(); // Use description for more detail
  const mainCondition = weatherData.weather[0].main.toLowerCase(); // Use main for general categories
  const icon = weatherData.weather[0].icon;
  const tempCelsius = weatherData.main.temp;

  if (icon && icon.endsWith('n')) {
    if (description.includes('clear sky')) newWeatherClass = 'clear-night';
    else if (description.includes('few clouds')) newWeatherClass = 'clear-night'; // Few clouds at night can still be clear-night
    else if (description.includes('scattered clouds')) newWeatherClass = 'cloudy-night'; // New class for scattered clouds at night
    else if (description.includes('broken clouds') || description.includes('overcast clouds')) newWeatherClass = 'overcast-night'; // New class for darker clouds at night
    else if (mainCondition.includes('rain') || mainCondition.includes('drizzle')) newWeatherClass = 'rainy';
    else if (mainCondition.includes('snow')) newWeatherClass = 'snowy';
    else if (mainCondition.includes('thunderstorm')) newWeatherClass = 'stormy';
    else if (mainCondition.includes('mist') || mainCondition.includes('fog') || mainCondition.includes('haze') || mainCondition.includes('smoke') || mainCondition.includes('sand') || mainCondition.includes('dust') || mainCondition.includes('ash') || mainCondition.includes('squall') || mainCondition.includes('tornado')) newWeatherClass = 'misty';
    else if (mainCondition.includes('clouds')) newWeatherClass = 'cloudy-night'; // Fallback for other cloud types at night
    else newWeatherClass = 'clear-night'; // Default night if no specific match
  } else {
    if (tempCelsius > 33) newWeatherClass = 'hot';
    else if (description.includes('clear sky')) newWeatherClass = 'sunny';
    else if (description.includes('few clouds')) newWeatherClass = 'sunny';
    else if (description.includes('scattered clouds')) newWeatherClass = 'cloudy'; // Existing cloudy for scattered
    else if (description.includes('broken clouds') || description.includes('overcast clouds')) newWeatherClass = 'overcast'; // New class for darker clouds
    else if (mainCondition.includes('rain') || mainCondition.includes('drizzle')) newWeatherClass = 'rainy';
    else if (mainCondition.includes('snow')) newWeatherClass = 'snowy';
    else if (mainCondition.includes('thunderstorm')) newWeatherClass = 'stormy';
    else if (mainCondition.includes('mist') || mainCondition.includes('fog') || mainCondition.includes('haze') || mainCondition.includes('smoke') || mainCondition.includes('sand') || mainCondition.includes('dust') || mainCondition.includes('ash') || mainCondition.includes('squall') || mainCondition.includes('tornado')) newWeatherClass = 'misty';
    else if (mainCondition.includes('clouds')) newWeatherClass = 'cloudy'; // Fallback for other cloud types during day
    else newWeatherClass = 'sunny'; // Default day if no specific match
  }

  if (newWeatherClass) {
    body.classList.add(newWeatherClass);
    console.log(`Applied background class: ${newWeatherClass}`);
  } else {
    console.log("No specific weather class applied, using default body background.");
  }
}

let myTemperatureChart = null;

function formatForecastTime(dateTimeStr) {
  const date = new Date(dateTimeStr);
  return date.toLocaleTimeString("vi-VN", { hour: '2-digit', minute: '2-digit', hour12: false });
}

function getDayName(timestamp) {
  const date = new Date(timestamp * 1000);
  return date.toLocaleDateString("vi-VN", { weekday: 'long' });
}

function renderHourlyForecast(hourlyData) {
  const container = document.querySelector("#forecastSection .hourly-forecast-grid");
  if (!container) return;
  container.innerHTML = ""; 

  hourlyData.slice(0, 8).forEach(item => {
    const time = formatForecastTime(item.dt_txt);
    const icon = weatherIcons[item.weather[0].icon] || "üå§Ô∏è";
    const temp = Math.round(item.main.temp);
    const itemHTML = `
      <div class="hourly-item">
        <div class="hourly-time">${time}</div>
        <div class="hourly-icon">${icon}</div>
        <div class="hourly-temp">${temp}¬∞C</div>
      </div>`;
    container.innerHTML += itemHTML;
  });
}

function renderDailyForecast(dailyDataList) {
  const container = document.querySelector("#forecastSection .daily-forecast-grid");
  if (!container) return;
  container.innerHTML = "";

  dailyDataList.forEach(day => {
    const dayName = getDayName(day.dt);
    const icon = weatherIcons[day.icon] || "üå§Ô∏è";
    const desc = day.description;
    const highTemp = Math.round(day.temp_max);
    const lowTemp = Math.round(day.temp_min);
    const itemHTML = `
      <div class="daily-item">
        <div class="daily-day">${dayName}</div>
        <div class="daily-desc">${desc}</div>
        <div class="daily-icon">${icon}</div>
        <div class="daily-temps">
          <span class="temp-high">${highTemp}¬∞</span> / <span class="temp-low">${lowTemp}¬∞</span>
        </div>
      </div>`;
    container.innerHTML += itemHTML;
  });
}

function renderTemperatureChart(hourlyData) {
  const ctx = document.getElementById('temperatureChart');
  if (!ctx) return;

  const labels = hourlyData.slice(0, 8).map(item => formatForecastTime(item.dt_txt));
  const temperatures = hourlyData.slice(0, 8).map(item => Math.round(item.main.temp));

  if (myTemperatureChart) {
    myTemperatureChart.destroy();
  }

  myTemperatureChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [{
        label: 'Nhi·ªát ƒë·ªô (¬∞C)',
        data: temperatures,
        borderColor: 'rgba(255, 255, 255, 0.8)',
        backgroundColor: 'rgba(255, 255, 255, 0.2)',
        tension: 0.4,
        fill: true,
        pointBackgroundColor: 'white',
        pointBorderColor: '#667eea',
        pointHoverRadius: 7,
        pointHoverBackgroundColor: '#667eea',
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: false,
          ticks: { color: 'rgba(255, 255, 255, 0.7)', callback: value => value + '¬∞C' },
          grid: { color: 'rgba(255, 255, 255, 0.1)', borderColor: 'rgba(255,255,255,0.1)' }
        },
        x: {
          ticks: { color: 'rgba(255, 255, 255, 0.7)' },
          grid: { display: false }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          backgroundColor: 'rgba(0,0,0,0.7)', titleFont: { size: 14 }, bodyFont: { size: 12 },
          padding: 10, cornerRadius: 5,
          callbacks: { label: context => `Nhi·ªát ƒë·ªô: ${context.parsed.y}¬∞C` }
        }
      }
    }
  });
}

async function getForecast(city) {
  const forecastHourlyContainer = document.querySelector("#forecastSection .hourly-forecast-grid");
  const forecastDailyContainer = document.querySelector("#forecastSection .daily-forecast-grid");

  if (forecastHourlyContainer) forecastHourlyContainer.innerHTML = `<p class="loading-text">ƒêang t·∫£i d·ª± b√°o theo gi·ªù...</p>`;
  if (forecastDailyContainer) forecastDailyContainer.innerHTML = `<p class="loading-text">ƒêang t·∫£i d·ª± b√°o h√†ng ng√†y...</p>`;

  try {
    const response = await fetch(`https://api.openweathermap.org/data/2.5/forecast?q=${city}&units=metric&lang=vi&appid=${API_KEY}`);
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || "Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu d·ª± b√°o.");
    }
    const forecastData = await response.json();

    renderHourlyForecast(forecastData.list);

    const dailyProcessed = {};
    forecastData.list.forEach(item => {
      const dateKey = item.dt_txt.split(' ')[0];
      if (!dailyProcessed[dateKey]) {
        dailyProcessed[dateKey] = { dt: item.dt, temps: [], icons: {}, descriptions: {} };
      }
      dailyProcessed[dateKey].temps.push(item.main.temp);
      const iconCode = item.weather[0].icon;
      const descText = item.weather[0].description;
      dailyProcessed[dateKey].icons[iconCode] = (dailyProcessed[dateKey].icons[iconCode] || 0) + 1;
      dailyProcessed[dateKey].descriptions[descText] = (dailyProcessed[dateKey].descriptions[descText] || 0) + 1;
    });

    const dailyForecastForRender = Object.values(dailyProcessed).map(dayData => {
      const mostCommonIcon = Object.keys(dayData.icons).reduce((a, b) => dayData.icons[a] > dayData.icons[b] ? a : b);
      const mostCommonDescription = Object.keys(dayData.descriptions).reduce((a, b) => dayData.descriptions[a] > dayData.descriptions[b] ? a : b);
      return {
        dt: dayData.dt,
        temp_min: Math.min(...dayData.temps),
        temp_max: Math.max(...dayData.temps),
        icon: mostCommonIcon,
        description: mostCommonDescription
      };
    }).slice(0, 7); // Display up to 7 days

    renderDailyForecast(dailyForecastForRender);
    renderTemperatureChart(forecastData.list);
  } catch (error) {
    console.error("L·ªói t·∫£i d·ª± b√°o:", error);
    if (forecastHourlyContainer) forecastHourlyContainer.innerHTML = `<p class="error-text" style="color:red; text-align:center;">${error.message}</p>`;
    if (forecastDailyContainer) forecastDailyContainer.innerHTML = `<p class="error-text" style="color:red; text-align:center;">${error.message}</p>`;
  }
}

// B·ªô chuy·ªÉn ƒë·ªïi t√™n T·ªânh sang Th√†nh ph·ªë ƒë·ªÉ API d·ªÖ nh·∫≠n d·∫°ng h∆°n
// Bao g·ªìm t·∫•t c·∫£ 63 t·ªânh th√†nh v√† c√°c t√™n g·ªçi ph·ªï bi·∫øn.
const provinceToCityMap = {
    // Mi·ªÅn B·∫Øc
    'h√† giang': 'H√† Giang', 'ha giang': 'H√† Giang',
    'cao b·∫±ng': 'Cao B·∫±ng', 'cao bang': 'Cao B·∫±ng',
    'b·∫Øc k·∫°n': 'B·∫Øc K·∫°n', 'bac kan': 'B·∫Øc K·∫°n',
    'l·∫°ng s∆°n': 'L·∫°ng S∆°n', 'lang son': 'L·∫°ng S∆°n',
    'tuy√™n quang': 'Tuy√™n Quang', 'tuyen quang': 'Tuy√™n Quang',
    'th√°i nguy√™n': 'Th√°i Nguy√™n', 'thai nguyen': 'Th√°i Nguy√™n',
    'ph√∫ th·ªç': 'Vi·ªát Tr√¨', 'phu tho': 'Vi·ªát Tr√¨',
    'b·∫Øc giang': 'B·∫Øc Giang', 'bac giang': 'B·∫Øc Giang',
    'qu·∫£ng ninh': 'H·∫° Long', 'quang ninh': 'H·∫° Long',
    'l√†o cai': 'L√†o Cai', 'lao cai': 'L√†o Cai',
    'y√™n b√°i': 'Y√™n B√°i', 'yen bai': 'Y√™n B√°i',
    'ƒëi·ªán bi√™n': 'ƒêi·ªán Bi√™n Ph·ªß', 'dien bien': 'ƒêi·ªán Bi√™n Ph·ªß',
    'h√≤a b√¨nh': 'H√≤a B√¨nh', 'hoa binh': 'H√≤a B√¨nh',
    'lai ch√¢u': 'Lai Ch√¢u', 'lai chau': 'Lai Ch√¢u',
    's∆°n la': 'S∆°n La', 'son la': 'S∆°n La',
    'b·∫Øc ninh': 'B·∫Øc Ninh', 'bac ninh': 'B·∫Øc Ninh',
    'h√† nam': 'Ph·ªß L√Ω', 'ha nam': 'Ph·ªß L√Ω',
    'h·∫£i d∆∞∆°ng': 'H·∫£i D∆∞∆°ng', 'hai duong': 'H·∫£i D∆∞∆°ng',
    'h∆∞ng y√™n': 'H∆∞ng Y√™n', 'hung yen': 'H∆∞ng Y√™n',
    'nam ƒë·ªãnh': 'Nam ƒê·ªãnh', 'nam dinh': 'Nam ƒê·ªãnh',
    'ninh b√¨nh': 'Ninh B√¨nh', 'ninh binh': 'Ninh B√¨nh',
    'th√°i b√¨nh': 'Th√°i B√¨nh', 'thai binh': 'Th√°i B√¨nh',
    'vƒ©nh ph√∫c': 'Vƒ©nh Y√™n', 'vinh phuc': 'Vƒ©nh Y√™n',
    'h√† n·ªôi': 'H√† N·ªôi', 'ha noi': 'H√† N·ªôi',
    'h·∫£i ph√≤ng': 'H·∫£i Ph√≤ng', 'hai phong': 'H·∫£i Ph√≤ng',

    // Mi·ªÅn Trung
    'thanh h√≥a': 'Thanh H√≥a', 'thanh hoa': 'Thanh H√≥a',
    'ngh·ªá an': 'Vinh', 'nghe an': 'Vinh',
    'h√† tƒ©nh': 'H√† Tƒ©nh', 'ha tinh': 'H√† Tƒ©nh',
    'qu·∫£ng b√¨nh': 'ƒê·ªìng H·ªõi', 'quang binh': 'ƒê·ªìng H·ªõi',
    'qu·∫£ng tr·ªã': 'ƒê√¥ng H√†', 'quang tri': 'ƒê√¥ng H√†',
    'th·ª´a thi√™n hu·∫ø': 'Hu·∫ø', 'thua thien hue': 'Hu·∫ø',
    'ƒë√† n·∫µng': 'ƒê√† N·∫µng', 'da nang': 'ƒê√† N·∫µng',
    'qu·∫£ng nam': 'Tam K·ª≥', 'quang nam': 'Tam K·ª≥',
    'qu·∫£ng ng√£i': 'Qu·∫£ng Ng√£i', 'quang ngai': 'Qu·∫£ng Ng√£i',
    'b√¨nh ƒë·ªãnh': 'Quy Nh∆°n', 'binh dinh': 'Quy Nh∆°n',
    'ph√∫ y√™n': 'Tuy H√≤a', 'phu yen': 'Tuy H√≤a',
    'kh√°nh h√≤a': 'Nha Trang', 'khanh hoa': 'Nha Trang',
    'ninh thu·∫≠n': 'Phan Rang-Th√°p Ch√†m', 'ninh thuan': 'Phan Rang-Th√°p Ch√†m', 'phan rang': 'Phan Rang-Th√°p Ch√†m',
    'b√¨nh thu·∫≠n': 'Phan Thi·∫øt', 'binh thuan': 'Phan Thi·∫øt',
    'kon tum': 'Kon Tum',
    'gia lai': 'Pleiku',
    'ƒë·∫Øk l·∫Øk': 'Bu√¥n Ma Thu·ªôt', 'dak lak': 'Bu√¥n Ma Thu·ªôt', 'bmt': 'Bu√¥n Ma Thu·ªôt',
    'ƒë·∫Øk n√¥ng': 'Gia Nghƒ©a', 'dak nong': 'Gia Nghƒ©a',
    'l√¢m ƒë·ªìng': 'ƒê√† L·∫°t', 'lam dong': 'ƒê√† L·∫°t',

    // Mi·ªÅn Nam
    'b√¨nh ph∆∞·ªõc': 'ƒê·ªìng Xo√†i', 'binh phuoc': 'ƒê·ªìng Xo√†i',
    'b√¨nh d∆∞∆°ng': 'Th·ªß D·∫ßu M·ªôt', 'binh duong': 'Th·ªß D·∫ßu M·ªôt',
    'ƒë·ªìng nai': 'Bi√™n H√≤a', 'dong nai': 'Bi√™n H√≤a',
    't√¢y ninh': 'T√¢y Ninh', 'tay ninh': 'T√¢y Ninh',
    'b√† r·ªãa v≈©ng t√†u': 'V≈©ng T√†u', 'ba ria vung tau': 'V≈©ng T√†u', 'brvt': 'V≈©ng T√†u',
    'h·ªì ch√≠ minh': 'Ho Chi Minh City', 'ho chi minh city': 'Ho Chi Minh City', 'hcm': 'Ho Chi Minh City', 'tp hcm': 'Ho Chi Minh City', 's√†i g√≤n': 'Ho Chi Minh City', 'sai gon': 'Ho Chi Minh City',
    'long an': 'T√¢n An',
    'ƒë·ªìng th√°p': 'Cao L√£nh', 'dong thap': 'Cao L√£nh',
    'ti·ªÅn giang': 'M·ªπ Tho', 'tien giang': 'M·ªπ Tho',
    'an giang': 'Long Xuy√™n',
    'b·∫øn tre': 'B·∫øn Tre', 'ben tre': 'B·∫øn Tre',
    'vƒ©nh long': 'Vƒ©nh Long', 'vinh long': 'Vƒ©nh Long',
    'tr√† vinh': 'Tr√† Vinh', 'tra vinh': 'Tr√† Vinh',
    'h·∫≠u giang': 'V·ªã Thanh', 'hau giang': 'V·ªã Thanh',
    'ki√™n giang': 'R·∫°ch Gi√°', 'kien giang': 'R·∫°ch Gi√°',
    's√≥c trƒÉng': 'S√≥c TrƒÉng', 'soc trang': 'S√≥c TrƒÉng',
    'b·∫°c li√™u': 'B·∫°c Li√™u', 'bac lieu': 'B·∫°c Li√™u',
    'c√† mau': 'C√† Mau', 'ca mau': 'C√† Mau',
    'c·∫ßn th∆°': 'C·∫ßn Th∆°', 'can tho': 'C·∫ßn Th∆°'
};

// Fetch current weather data
async function loadPageData(city) {
  // Chuy·ªÉn ƒë·ªïi t√™n t·ªânh th√†nh th√†nh ph·ªë n·∫øu c√≥ trong b·∫£n ƒë·ªì
  let searchCity = city.toLowerCase().trim();
  const mappedCity = provinceToCityMap[searchCity];
  if (mappedCity) {
    console.log(`√Ånh x·∫° "${city}" sang "${mappedCity}" ƒë·ªÉ g·ªçi API.`);
    searchCity = mappedCity;
  }

  try {
    // 1. Fetch current weather for background
    const weatherResponse = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(searchCity)}&units=metric&lang=vi&appid=${API_KEY}`);
    if (weatherResponse.ok) {
      const weatherData = await weatherResponse.json();
      setDynamicBackground(weatherData);
    } else {
      console.error("Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu th·ªùi ti·∫øt cho n·ªÅn.");
      setDynamicBackground(null); // S·ª≠ d·ª•ng n·ªÅn m·∫∑c ƒë·ªãnh
    }

    // 2. Fetch and render the forecast data
    await getForecast(searchCity);
  } catch (error) {
    const forecastHourlyContainer = document.querySelector("#forecastSection .hourly-forecast-grid");
    const forecastDailyContainer = document.querySelector("#forecastSection .daily-forecast-grid");
    if (forecastHourlyContainer) forecastHourlyContainer.innerHTML = `<p class="error-text" style="color:red; text-align:center;">L·ªói: ${error.message}</p>`;
    if (forecastDailyContainer) forecastDailyContainer.innerHTML = `<p class="error-text" style="color:red; text-align:center;">L·ªói: ${error.message}</p>`;
    setDynamicBackground(null); // Reset background on error
  }
}

// New function to get city name from coordinates using OpenWeatherMap Geocoding API
async function getCityFromCoordinates(lat, lon, apiKey) {
    try {
        const response = await fetch(`https://api.openweathermap.org/geo/1.0/reverse?lat=${lat}&lon=${lon}&limit=1&appid=${apiKey}`);
        if (!response.ok) {
            console.error("Failed to reverse geocode coordinates.");
            return null;
        }
        const data = await response.json();
        if (data && data.length > 0) {
            return data[0].name; // Return the city name
        }
        return null;
    } catch (error) {
        console.error("Error during reverse geocoding:", error);
        return null;
    }
}

// Function to get user's current location and fetch weather
async function loadWeatherBasedOnLocation(defaultCity, apiKey, pageLoadFunction) {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(async (position) => {
      const lat = position.coords.latitude;
      const lon = position.coords.longitude;
      const cityName = await getCityFromCoordinates(lat, lon, apiKey);
      if (cityName) {
        console.log(`Detected location: ${cityName}. Fetching weather.`);
        pageLoadFunction(cityName);
      } else {
        console.warn(`Could not determine city from coordinates. Falling back to ${defaultCity}.`);
        pageLoadFunction(defaultCity);
      }
    }, (error) => {
      console.warn(`Geolocation failed: ${error.message}. Falling back to ${defaultCity}.`);
      pageLoadFunction(defaultCity);
    }, { enableHighAccuracy: false, timeout: 5000, maximumAge: 0 });
  } else {
    console.warn(`Geolocation is not supported by this browser. Falling back to ${defaultCity}.`);
    pageLoadFunction(defaultCity);
  }
}

// Event listeners
document.addEventListener("DOMContentLoaded", () => {
  // Ki·ªÉm tra tr·∫°ng th√°i ƒëƒÉng nh·∫≠p
  fetch('/api/user')
    .then(response => response.json())
    .then(data => {
      if (data.isAuthenticated) {
        // Hi·ªÉn th·ªã th√¥ng tin ng∆∞·ªùi d√πng ƒë√£ ƒëƒÉng nh·∫≠p
        const userGreeting = document.getElementById('user-greeting');
        const authSection = document.getElementById('auth-section');
        const loginTriggerLink = document.getElementById('loginTriggerLink');
        
        if (userGreeting && authSection && loginTriggerLink) {
          userGreeting.textContent = `Xin ch√†o, ${data.user.displayName}`;
          userGreeting.style.display = 'inline-block';
          loginTriggerLink.style.display = 'none';
          
          // Th√™m n√∫t ƒëƒÉng xu·∫•t
          const logoutButton = document.createElement('a');
          logoutButton.href = '/auth/logout';
          logoutButton.className = 'nav-link';
          logoutButton.innerHTML = '<i class="fas fa-sign-out-alt"></i> ƒêƒÉng xu·∫•t';
          authSection.appendChild(logoutButton);
        }
      }
    })
    .catch(error => console.error('L·ªói khi ki·ªÉm tra tr·∫°ng th√°i ƒëƒÉng nh·∫≠p:', error));


  const urlParams = new URLSearchParams(window.location.search);
  const cityFromQuery = urlParams.get('city');

  if (cityFromQuery) { // If city is specified in URL, use it
    loadPageData(cityFromQuery);
    const cityInput = document.getElementById("cityInput");
    if (cityInput) cityInput.value = cityFromQuery; // T√πy ch·ªçn: ƒëi·ªÅn v√†o √¥ t√¨m ki·∫øm
  } else { // Otherwise, try to get location or use default
    loadWeatherBasedOnLocation(DEFAULT_CITY, API_KEY, loadPageData);
  }

  const cityInput = document.getElementById("cityInput");
  const searchIcon = document.querySelector(".search-icon"); // L·∫•y icon t√¨m ki·∫øm

  // H√†m x·ª≠ l√Ω t√¨m ki·∫øm ƒë·ªÉ tr√°nh l·∫∑p code
  function handleSearch() {
    if (cityInput && cityInput.value.trim()) {
      loadPageData(cityInput.value.trim());
    }
  }

  if (cityInput) {
    cityInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        handleSearch();
      }
    });
  }

  if (searchIcon) {
      searchIcon.addEventListener("click", handleSearch);
  }

  const tempUnitToggle = document.getElementById("tempUnitToggle");
  if (tempUnitToggle) {
    tempUnitToggle.addEventListener("change", () => {
      // Logic for temperature conversion needs to be robust,
      // considering current values are already displayed.
      // This is a placeholder for a more complex implementation
      // if you need to convert already displayed temperatures.
      console.log("Temperature unit toggled. Implement conversion logic.");
    });
  }

  const languageSelect = document.getElementById("languageSelect");
  if (languageSelect) {
    languageSelect.addEventListener("change", (e) => {
      const lang = e.target.value;
      console.log(`Language changed to: ${lang}. Implement I18N.`);
      // Implement language change logic here
      // This would involve reloading data with new lang param or using a translation library.
    });
  }

  // --- Login Modal Logic ---
  const loginTriggerLink = document.getElementById("loginTriggerLink");
  const loginModalElement = document.getElementById("loginModal");
  const closeModalButton = loginModalElement ? loginModalElement.querySelector(".modal-close-button") : null;

  const loginView = document.getElementById('loginView');
  const registerView = document.getElementById('registerView');
  const showRegisterViewLink = document.getElementById('showRegisterViewLink');
  const showLoginViewLink = document.getElementById('showLoginViewLink');

  const loginForm = document.getElementById('loginForm');
  const registerForm = document.getElementById('registerForm');
  const googleLoginButton = document.getElementById('googleLoginButton');

  // G·∫Øn s·ª± ki·ªán m·ªü modal cho li√™n k·∫øt "ƒêƒÉng nh·∫≠p"
  if (loginTriggerLink && loginModalElement) {
    loginTriggerLink.addEventListener("click", (event) => {
      event.preventDefault(); // NgƒÉn h√†nh vi m·∫∑c ƒë·ªãnh c·ªßa th·∫ª <a>
      loginModalElement.style.display = "flex";
      // M·∫∑c ƒë·ªãnh hi·ªÉn th·ªã form ƒëƒÉng nh·∫≠p khi m·ªü modal
      if(loginView) loginView.style.display = 'block';
      if(registerView) registerView.style.display = 'none';
    });
  }

  // G·∫Øn s·ª± ki·ªán ƒë√≥ng modal cho n√∫t "x"
  if (closeModalButton && loginModalElement) {
    closeModalButton.addEventListener("click", () => {
      loginModalElement.style.display = "none";
    });
  }

  // G·∫Øn s·ª± ki·ªán ƒë√≥ng modal khi click ra ngo√†i n·ªôi dung modal
  if (loginModalElement) {
    loginModalElement.addEventListener("click", (event) => {
      // Ch·ªâ ƒë√≥ng modal n·∫øu nh·∫•p v√†o l·ªõp ph·ªß (overlay) b√™n ngo√†i modal-content
      if (event.target === loginModalElement) {
        loginModalElement.style.display = "none";
      }
    });
  }

  // Logic chuy·ªÉn ƒë·ªïi gi·ªØa c√°c form ƒêƒÉng nh·∫≠p v√† ƒêƒÉng k√Ω
  if (showRegisterViewLink && loginView && registerView) {
    showRegisterViewLink.addEventListener('click', (event) => {
      event.preventDefault();
      loginView.style.display = 'none';
      registerView.style.display = 'block';
    });
  }

  if (showLoginViewLink && loginView && registerView) {
    showLoginViewLink.addEventListener('click', (event) => {
      event.preventDefault();
      registerView.style.display = 'none';
      loginView.style.display = 'block';
    });
  }

  // X·ª≠ l√Ω ƒëƒÉng nh·∫≠p
  if (loginForm) {
    loginForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      
      const email = document.getElementById('loginEmail').value;
      const password = document.getElementById('loginPassword').value;
      
      try {
        const response = await fetch('/auth/login', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ email, password })
        });
        
        const data = await response.json();
        
        if (data.success) {
          // ƒêƒÉng nh·∫≠p th√†nh c√¥ng
          const userGreeting = document.getElementById('user-greeting');
          const loginTriggerLink = document.getElementById('loginTriggerLink');
          const authSection = document.getElementById('auth-section');
          const loginModal = document.getElementById('loginModal');
          
          if (userGreeting && loginTriggerLink && authSection) {
            userGreeting.textContent = `Xin ch√†o, ${data.user.displayName}`;
            userGreeting.style.display = 'inline-block';
            loginTriggerLink.style.display = 'none';
            
            // Th√™m n√∫t ƒëƒÉng xu·∫•t
            const logoutButton = document.createElement('a');
            logoutButton.href = '/auth/logout';
            logoutButton.className = 'nav-link';
            logoutButton.innerHTML = '<i class="fas fa-sign-out-alt"></i> ƒêƒÉng xu·∫•t';
            authSection.appendChild(logoutButton);
            
            // ƒê√≥ng modal ƒëƒÉng nh·∫≠p
            if (loginModal) {
              loginModal.style.display = 'none';
            }
            
            // L√†m m·ªõi trang ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i
            window.location.reload();
          }
        } else {
          // ƒêƒÉng nh·∫≠p th·∫•t b·∫°i
          alert(data.message || 'ƒêƒÉng nh·∫≠p th·∫•t b·∫°i. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin.');
        }
      } catch (error) {
        console.error('L·ªói ƒëƒÉng nh·∫≠p:', error);
        alert('ƒê√£ x·∫£y ra l·ªói khi ƒëƒÉng nh·∫≠p. Vui l√≤ng th·ª≠ l·∫°i sau.');
      }
    });
  }
  
  // X·ª≠ l√Ω ƒëƒÉng k√Ω
  if (registerForm) {
    registerForm.addEventListener('submit', async (event) => {
      event.preventDefault();
      
      const email = document.getElementById('registerEmail').value;
      const password = document.getElementById('registerPassword').value;
      const confirmPassword = document.getElementById('registerConfirmPassword').value;
      
      // Ki·ªÉm tra m·∫≠t kh·∫©u
      if (password !== confirmPassword) {
        alert('M·∫≠t kh·∫©u x√°c nh·∫≠n kh√¥ng kh·ªõp!');
        return;
      }
      
      if (password.length < 6) {
        alert('M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±!');
        return;
      }
      
      try {
        const response = await fetch('/auth/register', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ email, password })
        });
        
        const data = await response.json();
        
        if (data.success) {
          // ƒêƒÉng k√Ω th√†nh c√¥ng
          const userGreeting = document.getElementById('user-greeting');
          const loginTriggerLink = document.getElementById('loginTriggerLink');
          const authSection = document.getElementById('auth-section');
          const loginModal = document.getElementById('loginModal');
          
          if (userGreeting && loginTriggerLink && authSection) {
            userGreeting.textContent = `Xin ch√†o, ${data.user.displayName}`;
            userGreeting.style.display = 'inline-block';
            loginTriggerLink.style.display = 'none';
            
            // Th√™m n√∫t ƒëƒÉng xu·∫•t
            const logoutButton = document.createElement('a');
            logoutButton.href = '/auth/logout';
            logoutButton.className = 'nav-link';
            logoutButton.innerHTML = '<i class="fas fa-sign-out-alt"></i> ƒêƒÉng xu·∫•t';
            authSection.appendChild(logoutButton);
            
            // ƒê√≥ng modal ƒëƒÉng nh·∫≠p
            if (loginModal) {
              loginModal.style.display = 'none';
            }
            
            // L√†m m·ªõi trang ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i
            window.location.reload();
          }
        } else {
          // ƒêƒÉng k√Ω th·∫•t b·∫°i
          alert(data.message || 'ƒêƒÉng k√Ω th·∫•t b·∫°i. Vui l√≤ng th·ª≠ l·∫°i.');
        }
      } catch (error) {
        console.error('L·ªói ƒëƒÉng k√Ω:', error);
        alert('ƒê√£ x·∫£y ra l·ªói khi ƒëƒÉng k√Ω. Vui l√≤ng th·ª≠ l·∫°i sau.');
      }
    });
  }
  if (googleLoginButton) {
    googleLoginButton.addEventListener("click", () => {
      window.location.href = '/auth/google';
      loginModalElement.style.display = 'none'; // ƒê√≥ng modal sau khi nh·∫•p
    });
  }
});